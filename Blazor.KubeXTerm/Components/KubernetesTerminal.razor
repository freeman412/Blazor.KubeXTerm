@using XtermBlazor
@using k8s
@using Utils
@using KubeXTerm.Services

@implements IAsyncDisposable
@inject IJSRuntime JsRuntime

@rendermode @(new InteractiveServerRenderMode(prerender: false))

<div @ref="_hostRef" class="kxterm-terminal-host">
    <div class="kxterm-shell">
        <Xterm OnData="@WriteToTerminal"
               Addons="_addons"
               @ref="_term"
               Options="_options"
               OnFirstRender="@OnFirstRender"
               Style="@Style"
               Class="kxterm-xterm"
               OnRender="FitTerminal" />
    </div>
</div>

@code 
{
    [Parameter] public string Style { get; set; } = "flex:1 1 auto; min-height:0; padding:5px";
    [Parameter] public string Namespace { get; set; } = "default";
    [Parameter, EditorRequired] public required string PodName { get; set; }
    [Parameter] public string? ContainerName { get; set; }
    [Parameter, EditorRequired] public required IKubernetes K8SContext { get; set; }
    [Parameter, EditorRequired] public required string ConnectionType { get; set; }
    [Parameter] public string[] Command { get; set; } = [ "/bin/bash" ];

    private Xterm _term;
    private readonly HashSet<string> _addons = ["addon-fit"];
    private KubeXTermConnectionManager _kubeExecutor;
    private TerminalOptions _options;
    private readonly CancellationTokenSource _cancellationTokenSource = new();
    private DotNetObjectReference<KubernetesTerminal> _dotNetRef;
    private ElementReference _hostRef;

    protected override void OnParametersSet()
    {
        bool disableStdin = ConnectionType != K8SConnectionType.Bash;
        bool convertEol = disableStdin;

        _options = new TerminalOptions
        {
            CursorBlink = true,
            CursorStyle = CursorStyle.Bar,
            FontFamily = "monospace",
            ConvertEOL = convertEol,
            DisableStdin = disableStdin,
            Theme =
            {
                Background = "#282a36",
                Foreground = "#bacfc7"
            }
        };
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            // Register the host for resize observation
            await JsRuntime.InvokeVoidAsync("kxterm.register", _hostRef, _dotNetRef);
        }
    }

    private async Task OnFirstRender()
    {
        _kubeExecutor = new KubeXTermConnectionManager(_term, K8SContext, Namespace);
        await FitTerminal();
        await StartTerminalConnection();
    }

    private async Task StartTerminalConnection()
    {
        try
        {
            if (ConnectionType == K8SConnectionType.Bash)
                await _kubeExecutor.ExecInPod(PodName, ContainerName, Command);
            else if (ConnectionType == K8SConnectionType.Stdout)
                await _kubeExecutor.StdOutInPod(PodName, ContainerName);
            else if (ConnectionType == K8SConnectionType.Logs)
                await _kubeExecutor.LogsInPodAync(PodName, ContainerName);
            else if (ConnectionType == K8SConnectionType.Stderr)
                await _kubeExecutor.StdErrInPod(PodName, ContainerName);
            else if (ConnectionType == K8SConnectionType.Alllogs)
                await _kubeExecutor.AllLogsAsync(PodName, ContainerName);
        }
        catch (Exception e)
        {
            Console.WriteLine($"Error in StartTerminalConnection: {e.Message}");
            _term.WriteLine("Unable to initiate terminal connection.");
        }
    }

    private async Task WriteToTerminal(string data) => await _kubeExecutor.WriteStream(data);

    private async Task SendResize()
    {
        if (_kubeExecutor == null || _term == null) return;
        int rows = await _term.GetRows();
        int cols = await _term.GetColumns();
        await _kubeExecutor.SendResizeCommandAsync(rows, cols);
    }

    private async Task FitTerminal()
    {
        if (_term == null) return;
        await _term.Addon("addon-fit").InvokeVoidAsync("fit");
        await SendResize();
    }

    [JSInvokable]
    public async Task FitNow() => await FitTerminal();

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (_dotNetRef != null)
            {
                await JsRuntime.InvokeVoidAsync("kxterm.unregister", _hostRef);
                _dotNetRef.Dispose();
            }
            _kubeExecutor?.DisposeAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Dispose error: {ex.Message}");
        }

        _cancellationTokenSource.Cancel();
        _cancellationTokenSource.Dispose();
    }
}
